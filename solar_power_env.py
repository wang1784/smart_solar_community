from get_comed_data import get_comed_data
import pandas as pd
import matplotlib.pyplot as plt
# from get_solar_data import get_solar_data
#
def combine_data():
    #get data from comed and solar
    df_comed = get_comed_data().account_hourly() #call function to get comed data
    df_solar = pd.read_csv('solar_data.csv', names = ['Datetime', 'SOLAR_W']).drop(0) #read solar data from csv file
    df_solar['Datetime'] = df_solar['Datetime'].str.replace('-06:00', '') #drop unuseful information so that datetime is consistent with comed data
    df_solar.set_index('Datetime', inplace = True) # set datetime as index
    df_join = df_comed.join(df_solar, how = 'inner', sort = True) #join two dataframes according to date and time

    #discretize data
    df_join['solar_bin'] = pd.cut(x=df_join['SOLAR_W'],
                             bins=[-0.75,0,50,100,150,200],
                             labels=[0, 1, 2, 3, 4])
    df_join['SOLAR_W'] = df_join['SOLAR_W'] * 16 #get 16 panels
    df_join['comed_bin'] = pd.cut(x = df_join['COMED_W'],
                                  bins = [1900, 2800, 3100, 4500, 6500],
                                  labels = [0, 1, 2, 3])
    #print dataframe info
    print(df_join.head())
    print(df_join.describe())
    print('comed\n', df_join['comed_bin'].value_counts())
    print('solar\n', df_join['solar_bin'].value_counts())

    #graph
    # plt.plot(range(df_join.shape[0]), df_join['COMED_W'])
    # plt.plot(range(df_join.shape[0]), df_join['SOLAR_W'])
    # plt.show()
    return df_join

class solar_power_env():
    def __init__(self, modules):
        #modules is an integer for how many modules we want for each household
        self._data = combine_data()
        self._data = self._data['SOLAR_W'] * modules #multiply the solar generated per module by number of module to get total power generated
        self._battery_cap = 1200 #max power can be stored in the battery
        self._data_step = 0 #row index to extract data from dataframe, starting with index 0
        p_init = self._data.iloc[0]
        seLf._state = [p_init['SOLAR_W'], p_init['COMED_W'], 0] #initiate state

    def extract_from_table(self, reward): #finds p_solar, p_comed
        p = self._data.iloc[self._data_step]
        return [p['SOLAR_W'], p['COMED_W'], self._state[2]+reward]


    def get_reward(self, action):
        #action is either -1 (discharging the battery) or 1 (charging the battery)
        #state = [p_solar, p_load, p_battery], where p_solar and p_load are values at time t, p_battery is at time t-1
        p_solar = self._state[0] #power generated by solar panel
        p_load = self._state[1] #power consumption
        p_battery = self._state[2] #power stored in battery currently

        if action: #if action==1, charging
            reward = min(p_solar, max(0, self._battery_cap - p_battery))
        else: #if action==-1, discharging
            reward = min(p_load, p_battery)
        return reward

    def step(self, action):
        # get reward
        reward = self.get_reward(action) #get reward of current state and action

        #apply changes in state
        self._data_step += 1 #update the row index
        battery_change = action*reward #if charging apply positive change to battery, if discharging, apply negative change
        self._state = extract_from_table(battery_change) #update the state with new data from table and the reward of current step

        #determine if terminal
        term = True if self._data_step == (self._data.shape[0]-1) else False #if we reach the last row of the dataframe, it's terminal

        return tuple(self._state), abs(reward), term


combine_data()